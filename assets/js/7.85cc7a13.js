(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{369:function(v,_,l){"use strict";l.r(_);var t=l(23),i=Object(t.a)({},(function(){var v=this,_=v.$createElement,l=v._self._c||_;return l("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[l("h1",{attrs:{id:"接口"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#接口"}},[v._v("#")]),v._v(" 接口")]),v._v(" "),l("p",[v._v("如果时间大于当前时间1分钟，就拒绝接收。")]),v._v(" "),l("ul",[l("li",[l("p",[v._v("获取A的订阅频道列表")]),v._v(" "),l("ul",[l("li",[v._v("参数\n"),l("ul",[l("li",[v._v("订阅的起始时间")])])]),v._v(" "),l("li",[v._v("返回\n"),l("ul",[l("li",[v._v("[ 订阅的频道公钥 订阅时间 ]")])])])])]),v._v(" "),l("li",[l("p",[v._v("获取频道标题")]),v._v(" "),l("ul",[l("li",[v._v("参数\n"),l("ul",[l("li",[v._v("频道的公钥")])])]),v._v(" "),l("li",[v._v("返回\n"),l("ul",[l("li",[v._v("时间戳")]),v._v(" "),l("li",[v._v("频道的标题")]),v._v(" "),l("li",[v._v("频道对标题(标题+时间戳)的签名")])])])])]),v._v(" "),l("li",[l("p",[v._v("获取频道的订阅者")]),v._v(" "),l("ul",[l("li",[v._v("参数\n"),l("ul",[l("li",[v._v("编辑距离")])])]),v._v(" "),l("li",[v._v("返回\n"),l("ul",[l("li",[v._v("[公钥 信用分]\n"),l("ul",[l("li",[v._v("积分计算公式\n"),l("ul",[l("li",[v._v("推送成功一次 积分 = log(e**积分 + (t-1624596444)/7/24/3600))")])])])])])])])])]),v._v(" "),l("li",[l("p",[v._v("获取频道下一个更新哈希, 更新哈希是merkletree")]),v._v(" "),l("ul",[l("li",[v._v("参数\n"),l("ul",[l("li",[v._v("频道的公钥")]),v._v(" "),l("li",[v._v("当前哈希 （如果为空，表示头开始）")])])]),v._v(" "),l("li",[v._v("返回\n"),l("ul",[l("li",[v._v("没更新 返回 空\n"),l("ul",[l("li",[v._v("如果发现对方比自己新，反向请求对方来更新自己")])])]),v._v(" "),l("li",[v._v("有更新（成功更新后，给对方节点信用加一）\n"),l("ul",[l("li",[v._v("时间戳 (不能大于当前系统时间+100秒，不能小于前一个哈希的时间，否则忽略)")]),v._v(" "),l("li",[v._v("哈希")]),v._v(" "),l("li",[v._v("更新内容的大小")]),v._v(" "),l("li",[v._v("文件名 不超过128个中文字符（或256个英文）")]),v._v(" "),l("li",[v._v("频道对标题(时间戳+文件名+哈希+更新内容大小+上一个哈希)的签名")])])])])])])]),v._v(" "),l("li",[l("p",[v._v("通过哈希获取merkletree")]),v._v(" "),l("ul",[l("li",[v._v("参数\n"),l("ul",[l("li",[v._v("哈希")]),v._v(" "),l("li",[v._v("offset")]),v._v(" "),l("li",[v._v("位图")])])]),v._v(" "),l("li",[v._v("返回值\n"),l("ul",[l("li",[v._v("哈希")]),v._v(" "),l("li",[v._v("offset")])])])])])]),v._v(" "),l("p",[v._v("// 每个文件如果大于1458176字节就有一个merkletree哈希文件\n// 文件下载下来之后会做一次merkletree效验，如果有问题")]),v._v(" "),l("ul",[l("li",[l("p",[v._v("通过哈希获取内容")]),v._v(" "),l("ul",[l("li",[v._v("参数\n"),l("ul",[l("li",[v._v("哈希")]),v._v(" "),l("li",[v._v("offset")])])]),v._v(" "),l("li",[v._v("返回值\n"),l("ul",[l("li",[v._v("哈希")]),v._v(" "),l("li",[v._v("offset")])])])]),v._v(" "),l("p",[v._v("下载进度的数据结构")]),v._v(" "),l("ul",[l("li",[v._v("起始offset")]),v._v(" "),l("li",[v._v("收到的碎片offset")]),v._v(" "),l("li",[v._v("结束offset")])]),v._v(" "),l("p",[v._v("拥塞控制")]),v._v(" "),l("p",[v._v("上一秒收到的包数\n这一秒收到的包数\n当前请求包的速度 // 初始请求的包速度为 1024*1024 字节 (可配置？)")]),v._v(" "),l("p",[v._v("if 如果这一秒收到的包数 >= 当前请求包的速度\n每秒请求的包数 = 请求包的速度*2 + 1\nelse\n每秒请求的包数 = max(这一秒收到的包数,上一秒收到的包数)+1")]),v._v(" "),l("p",[v._v("丢包重发")]),v._v(" "),l("ul",[l("li",[l("p",[v._v("begin = 最后一个获得的包 - 当前请求包的速度 * 4(可配置？)\nif begin > 起始offset\nfor i in 起始+1 to begin\n如果 not in 收到\n位图为1")]),v._v(" "),l("p",[v._v("不超过1424字节\n不超过每秒请求的包数")])])]),v._v(" "),l("p",[v._v("if 收到的包数 >= 请求的包数\n请求的包数 = 请求的包数+1\nelse\n请求的包数 = max(1,请求的包数/2)")]),v._v(" "),l("p",[v._v("请求流程")]),v._v(" "),l("ul",[l("li",[v._v("最后一个碎片的offset")])]),v._v(" "),l("p",[v._v("收到响应")]),v._v(" "),l("ul",[l("li",[v._v("如果碎片 = 开始+1\nn = 1"),l("br"),v._v("\n-> 如果最后一个碎片 == n\nend -= 1\ncontinue\n-> 如果n > end\n丢弃\nbreak\n-> 检查是否开始+n的碎片\n如有\n++n\ncontinue\n-> 开始+=n\nbreak")])]),v._v(" "),l("p",[v._v("1472-8(xxh3)-32(hash)-8(offset) = 1424")])])]),v._v(" "),l("h1",{attrs:{id:"https-doc-rust-lang-org-std-io-trait-seek-html"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#https-doc-rust-lang-org-std-io-trait-seek-html"}},[v._v("#")]),v._v(" https://doc.rust-lang.org/std/io/trait.Seek.html")]),v._v(" "),l("h1",{attrs:{id:"https-docs-rs-memmap-0-7-0-memmap-struct-mmapmut-html"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#https-docs-rs-memmap-0-7-0-memmap-struct-mmapmut-html"}},[v._v("#")]),v._v(" https://docs.rs/memmap/0.7.0/memmap/struct.MmapMut.html")]),v._v(" "),l("h1",{attrs:{id:"https-github-com-oconnor663-bao"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#https-github-com-oconnor663-bao"}},[v._v("#")]),v._v(" https://github.com/oconnor663/bao")]),v._v(" "),l("p",[v._v("频道更新哈希可以获取频道更新的目录")]),v._v(" "),l("p",[v._v("接口\n获取A的订阅列表，按A同步次数排序\n查找节点公钥")]),v._v(" "),l("p",[v._v("KAD网络设计")]),v._v(" "),l("p",[v._v("有64个桶，每个桶大小为8，当前一个桶被填满的时候，会分裂一下去填充下一个桶。")]),v._v(" "),l("p",[v._v("每个桶再保留32个作为候补，这样就有 32"),l("em",[v._v("8")]),v._v("16 = 4096个候补。")]),v._v(" "),l("p",[v._v("每个节点会与自己相近的32"),l("em",[v._v("8")]),v._v("16=2048个节点保持通讯\n心跳包每19秒一次\nUDP 空包的大小 = IP头(20) + UDP头(8) = 28\n也就是理论上维持连接的带宽消耗为 2048/19*28 = 3242字节每秒\n事实上应该没有这么多，因为不会32个bucket都填满")]),v._v(" "),l("p",[v._v("网络接口")]),v._v(" "),l("p",[v._v("FIND 公钥")]),v._v(" "),l("p",[v._v("返回公钥编辑距离对应的kad桶和候补桶\n如果不足24个，从前后的桶取可用+候补的填充直到填满24个\n返回公钥+IP端口")]),v._v(" "),l("h1",{attrs:{id:"数据库设计"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#数据库设计"}},[v._v("#")]),v._v(" 数据库设计")]),v._v(" "),l("p",[v._v("表")]),v._v(" "),l("ol",{attrs:{start:"0"}},[l("li",[l("p",[v._v("id - 私钥")])]),v._v(" "),l("li",[l("p",[v._v("公钥 - id")])]),v._v(" "),l("li",[l("p",[v._v("登录时间 - 私钥id")])]),v._v(" "),l("li",[l("p",[v._v("私钥id - 登录时间")])]),v._v(" "),l("li",[l("p",[v._v("私钥id - 用户昵称(不超过32个字符)")])]),v._v(" "),l("li",[l("p",[v._v("id - 公钥")])]),v._v(" "),l("li",[l("p",[v._v("id - 公钥id + 前一个公钥id  // 我订阅的公钥")])]),v._v(" "),l("li",[l("p",[v._v("id -")])])]),v._v(" "),l("p",[v._v("// 公钥的订阅者\n// 100. id - 可用的IPV4 & 端口\n// 101. 最后成功连接的时间 - ipv4.id\n// 102. ipv4.id - 最后成功连接时间\n// 103. ipv4.id - 公钥id // 1-1\n// 104. 公钥id - ipv4.id // 1-n")]),v._v(" "),l("p",[v._v("订阅A频道\n广度遍历A的订阅者\nA按照Kad存储32"),l("em",[v._v("8")]),v._v("16=不超过4096个订阅者\n不断迭代填充自己的K桶\n检测更新\n同步内容")]),v._v(" "),l("p",[v._v("为了防止攻击，每个订阅者订阅需要给A支付")])])}),[],!1,null,null,null);_.default=i.exports}}]);