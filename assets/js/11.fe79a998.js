(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{370:function(e,t,r){"use strict";r.r(t);var n=r(23),a=Object(n.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"技术栈-参考资料"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#技术栈-参考资料"}},[e._v("#")]),e._v(" 技术栈 & 参考资料")]),e._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"https://docs.rs/crate/sdb",target:"_blank",rel:"noopener noreferrer"}},[e._v("嵌入式数据库 sdb"),r("OutboundLink")],1)])]),e._v(" "),r("h2",{attrs:{id:"rust"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#rust"}},[e._v("#")]),e._v(" rust")]),e._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"https://rustwiki.org/zh-CN/rust-by-example",target:"_blank",rel:"noopener noreferrer"}},[e._v("通过例子学Rust"),r("OutboundLink")],1)]),e._v(" "),r("li",[r("a",{attrs:{href:"https://colobu.com/2019/08/13/strategies-for-returning-references-in-rust/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Rust返回引用的不同策略"),r("OutboundLink")],1)]),e._v(" "),r("li",[r("a",{attrs:{href:"http://chenyukang.github.io/2019/01/18/rust-dbg.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Rust的dbg!宏"),r("OutboundLink")],1)]),e._v(" "),r("li",[r("a",{attrs:{href:"https://blog.lxdlam.com/post/b63a9600/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Rust的包装类型"),r("OutboundLink")],1)]),e._v(" "),r("li",[r("a",{attrs:{href:"http://kaisery.github.io/trpl-zh-cn",target:"_blank",rel:"noopener noreferrer"}},[e._v("Rust程序设计语言"),r("OutboundLink")],1)]),e._v(" "),r("li",[r("a",{attrs:{href:"https://learnku.com/docs/nomicon/2018",target:"_blank",rel:"noopener noreferrer"}},[e._v("Rust高级编程"),r("OutboundLink")],1)])]),e._v(" "),r("h3",{attrs:{id:"学习笔记"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#学习笔记"}},[e._v("#")]),e._v(" 学习笔记")]),e._v(" "),r("h4",{attrs:{id:"堆栈和box"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#堆栈和box"}},[e._v("#")]),e._v(" 堆栈和Box")]),e._v(" "),r("p",[e._v("rust 不能返回 unsized 的 trait，但是可以返回 "),r("code",[e._v("Box<unsized trait>")])]),e._v(" "),r("p",[e._v("这是因为"),r("code",[e._v("Box<T>")]),e._v("指向堆上的数据，参考 "),r("a",{attrs:{href:"https://kaisery.github.io/trpl-zh-cn/ch15-01-box.html#%E4%BD%BF%E7%94%A8box-t%E6%8C%87%E5%90%91%E5%A0%86%E4%B8%8A%E7%9A%84%E6%95%B0%E6%8D%AE",target:"_blank",rel:"noopener noreferrer"}},[e._v("使用"),r("code",[e._v("Box <T>")]),e._v("指向堆上的数据"),r("OutboundLink")],1),e._v("。")]),e._v(" "),r("p",[e._v("堆上的数据，是运行时候根据数据类型，动态申请的内存 ; 而栈上的数据，是编译时候就明确数据类型的大小。")]),e._v(" "),r("p",[e._v("Box没有性能损耗，除了堆比栈慢一点。不过，性能过早最优化是万恶之源。")]),e._v(" "),r("p",[e._v("举一个实际工程中的例子：")]),e._v(" "),r("p",[e._v("下面代码("),r("a",{attrs:{href:"https://github.com/rmw-link/sdb/blob/master/src/iter.rs",target:"_blank",rel:"noopener noreferrer"}},[e._v("sdb/src/iter"),r("OutboundLink")],1),e._v(")的场景是，某些时候会直接返回停止了的迭代器（StopIter），而K和V大小是未定义的（?Sized）。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("pub fn key_iter<'a, T, K, V, P>(\n  txn: &'a T,\n  db: &Db_<K, V, P>,\n  key: &K,\n) -> Result<Box<dyn Iterator<Item = Result<(&'a K, &'a V), T::Error>> + 'a>, T::Error>\nwhere\n  T: LoadPage,\n  K: 'a + PartialEq + Storable + ?Sized,\n  V: 'a + Storable + ?Sized,\n  P: 'a + BTreePage<K, V>,\n{\n  let mut cursor = Cursor::new(txn, db)?;\n\n  match cursor.set(txn, key, None)? {\n    Some((key_c, _)) => Ok(Box::new(KeyIter {\n      cursor,\n      txn,\n      key: key_c,\n    })),\n    None => Ok(Box::new(StopIter::<T, K, V>(PhantomData {}))),\n  }\n}\n\npub struct StopIter<'a, T: LoadPage, K: PartialEq + Storable + ?Sized, V: Storable + ?Sized>(\n  PhantomData<(&'a T, &'a K, &'a V)>,\n);\n\nimpl<'a, T: LoadPage, K: PartialEq + Storable + ?Sized + 'a, V: Storable + ?Sized + 'a> Iterator\n  for StopIter<'a, T, K, V>\n{\n  type Item = Result<(&'a K, &'a V), T::Error>;\n  #[inline]\n  fn next(&mut self) -> Option<Self::Item> {\n    None\n  }\n}\n\npub struct KeyIter<\n  'a,\n  T: LoadPage,\n  K: PartialEq + Storable + ?Sized,\n  V: Storable + ?Sized,\n  P: BTreePage<K, V>,\n> {\n  txn: &'a T,\n  cursor: Cursor<K, V, P>,\n  key: &'a K,\n}\n\nimpl<\n    'a,\n    T: LoadPage,\n    K: PartialEq + Storable + ?Sized + 'a,\n    V: Storable + ?Sized + 'a,\n    P: BTreePage<K, V> + 'a,\n  > Iterator for KeyIter<'a, T, K, V, P>\n{\n  type Item = Result<(&'a K, &'a V), T::Error>;\n  #[inline]\n  fn next(&mut self) -> Option<Self::Item> {\n    let entry = self.cursor.next(self.txn).transpose();\n    match entry {\n      Some(kv) => match kv {\n        Ok((k, _)) => {\n          if k == self.key {\n            Some(kv)\n          } else {\n            None\n          }\n        }\n        _ => Some(kv),\n      },\n      _ => entry,\n    }\n  }\n}\n")])])]),r("h4",{attrs:{id:"to-owned"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#to-owned"}},[e._v("#")]),e._v(" "),r("code",[e._v("to_owned")])]),e._v(" "),r("p",[e._v("把数据从栈中复制到堆中，成为自己的数据。")]),e._v(" "),r("p",[e._v("一般就是转型为兄弟类型的数据，比如")]),e._v(" "),r("ul",[r("li",[e._v("&str => String")]),e._v(" "),r("li",[e._v("Path => PathBuf")])]),e._v(" "),r("h4",{attrs:{id:"feature-decl-macro"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#feature-decl-macro"}},[e._v("#")]),e._v(" "),r("code",[e._v("#![feature(decl_macro)]")])]),e._v(" "),r("p",[r("code",[e._v("macro_rules!")]),e._v(" 声明的宏没法使用use，否则会出现reimported（当调用一个宏多次之后）")]),e._v(" "),r("p",[e._v("加入 #![feature(decl_macro)] 之后就可以使用")]),e._v(" "),r("p",[e._v("类似这样的写法")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("#[macro_export]\npub macro repr($cls:ident) {\n  use sdb::direct_repr;\n  direct_repr!($cls);\n}\n")])])]),r("p",[e._v("参见 "),r("a",{attrs:{href:"https://github.com/rust-lang/rust/issues/39412",target:"_blank",rel:"noopener noreferrer"}},[e._v("声明性宏 2.0"),r("OutboundLink")],1)]),e._v(" "),r("h4",{attrs:{id:"过程宏"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#过程宏"}},[e._v("#")]),e._v(" 过程宏")]),e._v(" "),r("p",[e._v("过程宏就是自己解析语法树，输出代码。")]),e._v(" "),r("p",[e._v("过程宏必须是一个单独的包，可以用子包来实现。")]),e._v(" "),r("p",[e._v("参见 :")]),e._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"https://github.com/rmw-link/sdb",target:"_blank",rel:"noopener noreferrer"}},[e._v("sdb代码示例"),r("OutboundLink")],1)]),e._v(" "),r("li",[r("a",{attrs:{href:"https://dengjianping.github.io/2019/02/28/%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E8%BF%87%E7%A8%8B%E5%AE%8F(proc-macro).html",target:"_blank",rel:"noopener noreferrer"}},[e._v("如何编写一个过程宏(proc-macro)"),r("OutboundLink")],1)])])])}),[],!1,null,null,null);t.default=a.exports}}]);